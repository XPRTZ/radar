---
-
  name: Progressive Web App
  ring: adopt
  quadrant: techniques
  isNew: FALSE
  description: '<b>Progressive Web Apps</b> are web apps that use emerging web browser APIs and features along with traditional progressive enhancement strategy to bring a native app-like user experience to cross-platform web applications. By utilizing service workers that allow intercepting and control of how a web browser handles its network requests and asset caching, the user has reliable fast web pages and offline experience. One of our projects that uses a PWA is field worker application that allows its workers in the field to have a reliable web app experience while having to cope with unstable mobile connection. A beginner''s tutorial for setting up a PWA can be started <a href="https://www.smashingmagazine.com/2016/08/a-beginners-guide-to-progressive-web-apps/">here</a>'
-
  name: Cypress
  ring: trial
  quadrant: tools
  isNew: FALSE
  description: '<b>Cypress</b> is the next generation E2E testing tool that made itself famous by building its own architecture instead of using Selenium like most testing frameworks do. It''s an <a href="https://www.cypress.io/how-it-works/">all-in-one test suite</a> that is blazing fast, easy to setup and a delight to develop with. That''s what we like at XPRTZ so more than enough reason to assess it!'
-
  name: Yarp
  ring: assess
  quadrant: languages & frameworks
  isNew: FALSE
  description: 'With <a href="https://github.com/microsoft/reverse-proxy">Yarp</a> a .Net application can be extended with a build-in reverse proxy. In a world of frontend applications and many backend microservices, a reverse proxy could help to have a single endpoint for many different endpoints, aka servers. Yarp is a fast, lightweight, extendable .Net based Reverse proxy. Yarp uses the ASP.NET pipeline technology to manage incoming requests and routes the request streams to its destination. Routing could be done by configuration or in custom written logic. Because the reverse proxy application is just a piece of .Net code, its familiar and easy to work with. Namely, to code, to have it in source control and in your CI/CD pipeline and infrastructure.<br><br>Yarp is still experimental so for bigger projects, solutions like <a href="https://www.nginx.com/">Nginx</a> (a reverse-proxy) are a better solution. Yarp has potential, and in time could replace an <a href="https://github.com/ThreeMammals/Ocelot">Ocelot</a> (an api gateway) application (if you do not need the request/response bodies). At XPRTZ we keep track of this Microsoft project.'
-
  name: Vue3
  ring: hold
  quadrant: languages & frameworks
  isNew: FALSE
  description: 'For the past year <b>Vue</b> has been put to trial because it was the newest kid on the block when it comes to frontend frameworks. During the trial, we had to refactor our components design multiple times, because of a change of heart by the framework developers. Now that it has become somewhat more mature, we still haven''t been convinced on strong benefits above either React or Angular. Although the project continues with Vue 3 because we see impediments or other reason to migrate, we will put it on hold since future projects would favor React or Angular.'
-
  name: Fluxor
  ring: hold
  quadrant: languages & frameworks
  isNew: FALSE
  description: '<a href="https://github.com/mrpmorris/Fluxor">Fluxor</a> is a Flux/Redux implementation for use in .Net and Blazor, to separate state changes and state reads and to be able to reuse data in different parts of the application with a single source of truth. While the redux pattern is a useful pattern, this implementation is quite hard to test, without wiring up your whole application.'
-
  name: Blazor
  ring: adopt
  quadrant: languages & frameworks
  isNew: FALSE
  description: '<a href="https://dotnet.microsoft.com/apps/aspnet/web-apps/blazor">Blazor</a> is a client-side UI framework that allows you to build interactive web UIs using C#. Blazor apps are composed of reusable web UI components implemented using C#, HTML, and CSS. Both client and server code are written in C#, allowing you to share code and libraries. Blazor can run directly in the browser using WebAsssembly, alternatively it can run client-side logic on the server by sending UI events to the server and receiving UI changes back using SignalR.<br><br>In modern web development where there''s already an oversaturation of Javascript frameworks, Blazor offers .NET developers a new alternative to write client-side code without having to learn a new or unfamiliar language or framework.'
-
  name: Azure Cosmos DB
  ring: adopt
  quadrant: platforms
  isNew: FALSE
  description: '<a href="https://azure.microsoft.com/nl-nl/services/cosmos-db/">Azure Cosmos DB</a> is a fully managed NoSQL database that excels in high performance reads, automatic scaling across multiple global regions and above most other document databases also the option to use SQL-like queries.<br><br>We have adopted Cosmos DB because it fits our needs in a lot of projects and is easy to use while developing. When relational integrity is not necessary, we like the benefits of NoSQL databases and Cosmos DB specifically. Only when it comes to heavy relational datasets, we would revert to an actual SQL database.'
-
  name: Fluent Assertions
  ring: adopt
  quadrant: tools
  isNew: FALSE
  description: '<b>Fluent Assertions</b> is an extensive set of extension methods that allow you to more naturally specify the expected outcome of a TDD or BDD-style unit tests. Many of our XPRTZ colleagues have <a href="https://fluentassertions.com/">FluentAssertions</a> in their standard set of tools that are used for each project.'
-
  name: Terraform
  ring: adopt
  quadrant: tools
  isNew: FALSE
  description: '<a href="https://www.terraform.io/">Terraform</a> is an infrastructure-as-code (IaC) tool for provisioning and maintaining cloud services.<br><br>Infrastructure-as-code allows us to create and maintain the server configurations that we need to host our applications in an unambiguous and repeatable way. This increases the quality of our code because it eliminates any chance of differences between our development, test, acceptance and production environments.<br><br>One of the features of Terraform that we particularly like is its declarative syntax. This enables us to simply declare what the environment we want Terraform to create should look like, without needing to specify every single step that needs to be executed to create it. This also means that we can see exactly what is configured on each environment without having to parse dozens of install scripts.'
-
  name: Azure Kubernetes Service
  ring: adopt
  quadrant: platforms
  isNew: FALSE
  description: '<a href="https://azure.microsoft.com/nl-nl/services/kubernetes-service/">Azure Kubernetes Service</a> (AKS) is a cloud service for hosting and maintaining container applications on Microsoft Azure, using Kubernetes.<br><br>Kubernetes has quickly become the de-facto standard for orchestrating container applications. With AKS we have an easy-to-use tool for working with Kubernetes in the Azure cloud. Since we, as .NET developers, have a lot of experience and affinity with Microsoft Azure, AKS is the logical tool we reach for when building container applications.'
-
  name: FakeItEasy
  ring: adopt
  quadrant: tools
  isNew: FALSE
  description: 'With <a href="https://fakeiteasy.github.io/">FakeItEasy</a>, the unit under test can be isolated from dependencies on the rest of the system. Each external dependency is replaced with a dummy, mock, stub or fake, which in FakeItEasy are all the same, are created the same, only the usage determines what they are. The framework has an intuitive fluent syntax to setup each dependency and can manage and verify each of its calls including the parameters and return values with the same ease.<br><br>Other mocking/isolation frameworks such as NSubstitute and Moq do the same job, but FakeItEasy makes it really, yes, easy.'
-
  name: OpenShift
  ring: hold
  quadrant: platforms
  isNew: FALSE
  description: '<a href="https://www.openshift.com/">Red Hat OpenShift</a> is a product which can be seen as an extra layer on top of Kubernetes. With OpenShift you have more control over your containers. OpenShift contains a user-friendly dashboard which makes it easy to manage and create containers and images. On top of that, this platform provides tools like health checks and logging. These are one of the many core components from Red Hat OpenShift.<br><br>As organization you are in full control over which frameworks, apps and libraries are being used. This gives a lot of freedom to developers, because a developer can choose the components from a library.<br><br>With OpenShift developers can develop, test, and host (scalable) in one environment. Developers will mainly focus on developing instead of focusing on operating systems or infrastructure.<br><br>We have moved OpenShift from assess to hold. If your organization is already working with Microsoft technologies we would recommend to implement AKS (Azure Kubernetes Services) or plain Kubernetes instead of OpenShift. OpenShift comes with a lot of features but Microsoft Azure (for example) provides all the necessary tools and features to achieve the same as with OpenShift'
-
  name: AutoFixture
  ring: adopt
  quadrant: tools
  isNew: FALSE
  description: 'With <b>AutoFixture</b> you can easily create test fixures. While writing tests you want to focus on the test case and not be burdened by all the boring setup that is required. When initializing test objects with AutoFixture, only test relevant parts are specified, non-relevant parts are automatically filled with dummy data. Now your test case is focused on the essentials instead of object initialization.<br><br>We use this when writing unit tests. It makes Test-Driven Development a step easier and our lives as developers happier. There are alternatives such as Bogus, which also generates fake data in test objects. An advantage of AutoFixture is the initialization of all properties with data.Bogus only sets properties that are filled. It''s more which flavour you prefer. Our choice is <a href="https://github.com/AutoFixture/AutoFixture">AutoFixture</a>!'
-
  name: Event-driven architecture
  ring: adopt
  quadrant: techniques
  isNew: FALSE
  description: 'With <a href="https://martinfowler.com/articles/201701-event-driven.html">event-driven architecture</a> events are used to trigger and communicate between decoupled Microservices. An event is any change in a state like customer data being updated or other external triggers. There are three key components in event-driven architecture, namely event producers, event routers/mediators, and event consumers. The architecture is decoupled or loosely coupled because producers don''t know which consumers are listening for an event, and what the consequences are of its occurrence. The Azure platform itself can be used as an event producer, for example Cosmos DB change events or scaling events from App service plans.<br><br>Kafka or Dapr are good solutions to use in applications based on an event-driven architecture. But also basic messaging systems like <i>RabbitMQ</i>, <i>Service Bus</i> or <i>Azure Event Grid</i> will suffice but may require more "low-level" programming.'
-
  name: Infrastructure as Code
  ring: adopt
  quadrant: techniques
  isNew: FALSE
  description: 'As developers we love to automate as many mundane tasks as we can: building our software, testing it and deploying it to production can all be automated these days with CI/CD tools like Azure Pipelines or GitHub Actions. So why not do the same with provisioning and maintaining the infrastructure our applications run on? Now that many applications run on virtual infrastructures like VMs or even containers, there is no reason to manage these with software as well. That is what is called <a href="https://en.wikipedia.org/wiki/Infrastructure_as_code">Infrastructure as Code</a> (IaC).<br><br>By automating all management of the infrastructure we can both reduce the risk of environments getting out of sync (because we forget to install some updates on one of them) and increase the speed of scaling our environments in our out (because we don''t have to go through a length manual process to provision a new environment, it''s just an automated script).'
-
  name: Microservice Architecture
  ring: adopt
  quadrant: techniques
  isNew: FALSE
  description: 'Ask 10 different developers to define <a href="https://microservices.io/patterns/microservices.html">Microservice Architecture</a> and you''ll probably get 10 different responses. But at their core, microservices are just a way to design your software into independently deployable services that are loosely coupled.<br><br>Most developers with some years of experience have encountered applications where all systems are tightly coupled together so that it''s impossible to make or deploy changes to one system without having to change other systems as well. Or at the very least having to deploy everything all at once.<br><br>By splitting the application into independent services, it becomes possible to work on and deploy every service without having to wait on all other services. This means we can deploy more frequently (delivering more value to our customers) and make the deployments smaller (reducing the risk of mistakes or making them easier to find and fix).'
-
  name: CQRS Pattern
  ring: adopt
  quadrant: techniques
  isNew: FALSE
  description: '<a href="https://martinfowler.com/bliki/CQRS.html">Command and Query Responsibility Segregation</a> (CQRS) is an architecture pattern based on the Command and Query Separation (CQS) principle that states that methods should either be commands that perform an action, or queries that return data. CQRS is basically an extension of this principle where it''s applied throughout the architecture of the application, usually by creating different objects for queries and for commands.<br><br>By separating our application into commands and queries we make it possible to optimize both without influencing each other. For instance, in most systems a large portion of the transactions (both in actual number of transactions as in data being transferred) are queries. Because they are separated it becomes possible to scale the queries while leaving the commands-side relatively small (thus reducing cost).'
-
  name: Azure Service Bus
  ring: adopt
  quadrant: platforms
  isNew: FALSE
  description: '<a href="https://azure.microsoft.com/nl-nl/services/service-bus/">Azure Service Bus</a> is commonly used in our projects to decouple microservices. A big plus why we have adopted the Azure variant above other implementations is the high scalability and easy integration with our application landscape setup in Azure.'
-
  name: Azure Functions
  ring: adopt
  quadrant: platforms
  isNew: FALSE
  description: '<a href="https://azure.microsoft.com/nl-nl/services/functions/">Azure Functions</a> is Microsoft''s serverless computing offering and it allows us to further eliminate infrastructural code as it lives an abstraction level higher than container technology. This enables us to focus our developing efforts on the business logic of an application. Azure Functions can also be a cost-effective platform for low usage or highly fluctuating usage patterns.'
-
  name: Marten
  ring: assess
  quadrant: platforms
  isNew: FALSE
  description: '<a href="https://martendb.io/">Marten</a> is a library provided as a Nuget package which gives .NET developers the ability to easily use the PostgreSQL database engine and its JSON support as a fully-fledged document database. Many of the Marten contributors were fans of the existing RavenDb database but wanted a more robust underlying technology. To that end, Marten was largely created to efficiently use the proven PostgreSQL database engine as a document database and act as a near drop-in replacement for RavenDb in several existing applications. As such, you may clearly see some influence from RavenDb on the Marten services and API''s.<br><br>The feature we like the most is the ability to transform a PostgreSQL database in an event store with Marten. It utilizes the strong JSONB support to expose an ACID-compliant event store implementation over the PostgreSQL database. It also takes advantage of PostgreSQL''s embedded JavaScript support to enable effective user-defined projections against your event streams.'
-
  name: Dapr
  ring: assess
  quadrant: languages & frameworks
  isNew: TRUE
  description: '<a href="https://dapr.io/">Dapr</a> gives you building blocks for building distributed applications. The shift from monolithic applications to Microservices provided many benefits but also make developing more complex because all these microservices need to share many cross-cutting concerns. Dapr is specifically aimed to help by simplifying the development of distributed applications. Dapr is using Kubernetes as its primary cloud hosting environment, but it is not required. Alternatives include self-hosting using Docker or going serverless with Azure Container Apps. Dapr has pre-built components that solve a common set of problems in distributed applications, e.g., service invocation, state management, event handling and many more. The key concept of Dapr is that it uses sidecars (small applications running along with your Microservices) to operate its main functions. We are following the progress of Dapr with great interest and will continue to do so, but we’re still reluctant to using and recommending it due to the seemingly low adoption, poor development tooling and very specific fit for purpose.'
-
  name: Azure Static Web Apps
  ring: adopt
  quadrant: platforms
  isNew: FALSE
  description: 'With <a href="https://azure.microsoft.com/nl-nl/services/app-service/static/">Azure Static Web Apps</a>, developers can build modern, full-stack JavaScript web apps with static front-ends and optional dynamic back-ends powered by serverless APIs. <br><br>Azure Static WebApps interacts directly with GitHub or Azure DevOps to monitor a branch of choice. With every commit into the watched branch, a build is automatically run and the app and API is deployed to Azure.'
-
  name: GraphQL
  ring: adopt
  quadrant: languages & frameworks
  isNew: FALSE
  description: '<a href="https://graphql.org/">GraphQL</a> is a query language for API''s where the client of the API determines exactly what he wants to receive.<br><br>In most API''s when you execute an action you''re stuck with whatever object that action returns. If you only needed a portion of the result you''ve just received way more information than was necessary. Another common scenario is that you need to combine resources from multiple sources. Traditionally, this means you would have to query all sources separately and combine the data yourself.<br><br>With GraphQL, you can specify only the data that you need, even if it''s across multiple sources. This cleans up the client-side because you don''t need to create a lot of mappings to change what you receive from the API to what you actually need and it also reduces both the amount of API calls and the amount of wasted bandwidth sending data the client doesn''t need.'
-
  name: gRPC
  ring: adopt
  quadrant: languages & frameworks
  isNew: FALSE
  description: 'With <a href="https://grpc.io/">gRPC</a> it is possible to communicate with remote services in a modern high perforce manner. gRPC is a Remote Procedure Call (RPC) framework where services have clear interfaces and structured messages for requests and responses. It uses <a href="https://developers.google.com/protocol-buffers/docs/overview">Protobuf</a> to serialize the messages to a binary message format, making the payload significant smaller compared to JSON. It supports both HTTP and HTTP2.<br><br>Most web backend developers switched from SOAP to JSON (REST) / OpenAPI services past decade, and this is in many cases the best solution. However, when you have massive numbers of remote calls, milliseconds matter and both sides could be changed, gRPC should definitely be considered as a good alternative.<br><br>We prefer using gRPC in Microservice architecture environments where low latency is required.'
-
  name: Dependabot
  ring: trial
  quadrant: tools
  isNew: FALSE
  description: '<a href="https://dependabot.com/">Dependabot</a> is a Github tool used to automatically keep your project dependencies up to date. Dependabot first checks your project dependencies for any updates and if there are any a pull request is created. You can review and run the necessary tests on the pull request before merging it.<br><br>With Dependabot you spend less time updating your project dependencies and have more time to build.'
-
  name: Azure Pipelines
  ring: adopt
  quadrant: tools
  isNew: FALSE
  description: '<a href="https://azure.microsoft.com/nl-nl/services/devops/pipelines/">Azure Pipelines</a> automatically builds and tests code projects to make them available to others. It works with just about any language or project type. Azure Pipelines combine continuous integration (CI) and continuous delivery (CD) to constantly and consistently test and build your code and ship it to any target.'
-
  name: C# 8 - Nullable reference types
  ring: adopt
  quadrant: languages & frameworks
  isNew: FALSE
  description: 'Back in 1965 <a href="https://en.wikipedia.org/wiki/Tony_Hoare">Tony Hoare</a> introduced the null reference in <a href="https://en.wikipedia.org/wiki/ALGOL_W">ALGOL W</a> and this was copied by a lot of languages. Later Tony called this his billion-dollar mistake and apologized for the problem this has caused. C# was one of the languages that copied this feature and its developers and users had to suffer for it. Starting with C# 8.0 developers finally have the option to get rid of this pain with <a href="https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references">Nullable reference types</a>. Does this mean that null doesn''t exist anymore? No but you have to be explicit about it. Reference types now behave like value types, for example bool, int, char, etc.<br><br>We see this feature as a way to better declare the intent of our code and a good practice to prevent the dreaded Null Reference Exception.'
-
  name: C# 10 - File-scoped namespace declarations
  ring: adopt
  quadrant: languages & frameworks
  isNew: FALSE
  description: 'For better readability, code lines are limited to a maximum amount of characters, which becomes more limited by the number of nested scopes. <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-10.0/file-scoped-namespaces">File-scoped namespace declaration</a> allows us to fill up the limited space we have with our beautiful code instead of whitespace.'
-
  name: C# 10 - Global using definitions
  ring: adopt
  quadrant: languages & frameworks
  isNew: FALSE
  description: 'We believe in clean code and <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-10.0/globalusingdirective">global using definitions</a> introduced with C# 10 has given us some more control on cleaning a lot of boilerplate usings that are cluttering up the code files. By defining commonly used usings as global in a single code file, they no longer need to be defined in each single code file individually.'
-
  name: .NET 6 - Hot Reload
  ring: adopt
  quadrant: tools
  isNew: FALSE
  description: '<a href="https://devblogs.microsoft.com/dotnet/introducing-net-hot-reload/">.NET Hot Reload</a> is a new feature in .NET 6 that allows developers to modify their source code while the application is running. Front-end developers who work with frameworks like Angular, React or Vue will be familiar with this feature, but it''s new for .NET developers.<br><br>This feature greatly improves the developer experience while working on .NET applications. Instead of having to rebuild and restart our application every time we make a change, we can now keep the application running and see the effect of our changes immediately.<br><br>This has been a highly anticipated feature (as shown by the <a href="https://www.theverge.com/2021/10/22/22740701/microsoft-dotnet-hot-reload-removal-decision-open-source">uproar</a> that Microsoft triggered when they wanted to pull the feature from everything but Visual Studio just before the launch of .NET 6) and we see it as one of the main reasons for upgrading to .NET 6.'
-
  name: .NET 6 - Minimal Api
  ring: trial
  quadrant: languages & frameworks
  isNew: FALSE
  description: '<a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis">Minimal APIs</a> are a new feature in .NET 6 that allows you to create HTTP APIs with minimal dependencies. Minimal APIs are ideal for microservices and apps that only need minimal dependencies and features. If you are new to .NET, using Minimal APIs can be helpful, because you do not have to learn and understand the ASP.NET Core MVC framework first to create your HTTP API.<br><br>With Minimal APIs you can create new HTTP APIs with just a few lines of code. Features like API versioning are not available yet, however the most common used features like authorization, dependency injection, routing and model binding are. This means Minimal APIs will not replace the traditional MVC framework yet, but it is a new possibility to create a HTTP API.<br><br>We see Minimal APIs as an excellent choice for creating all kinds of new HTTP APIs and would consider using it when starting a new project.'
-
  name: .NET 6 - DateOnly & TimeOnly
  ring: adopt
  quadrant: languages & frameworks
  isNew: FALSE
  description: '.NET 6 introduces two new value types, <a href="https://devblogs.microsoft.com/dotnet/date-time-and-time-zone-enhancements-in-net-6/#introducing-the-dateonly-and-timeonly-types">DateOnly and TimeOnly</a>, that represent either only the date or time portion of a DateTime. Both types are available in the System namespace and are built-in to .NET. These two types solve the unnecessary component of the DateTime type when we''re only concerned about one portion. For example: When we want to save a date of birth we''re probably not concerned about the time component of a DateTime, in this case the DateOnly type is more ideal.'
-
  name: Stryke Mutator
  ring: assess
  quadrant: tools
  isNew: FALSE
  description: 'Stryker Mutator is a mutation testing framework for .NET, JavaScript and Scala. Mutation testing is used to test your unit tests by creating mutants, each mutant is a mutation of your code. For each mutant, all tests will be run to see if a test fails, this way you can check the quality of your tests and if you need to add more to cover more scenarios. On the <a href="https://stryker-mutator.io">website</a> you will find good documentation which makes it easy to start using Stryker Mutator. It also is very configurable and easy to integrate in your pipeline with the available dotnet tool.'
-
  name: Project Tye
  ring: trial
  quadrant: tools
  isNew: FALSE
  description: 'Tye is a developer tool that makes developing, testing, and deploying microservices and distributed applications easier. Project Tye includes a local orchestrator to make developing microservices easier and the ability to deploy microservices to Kubernetes with minimal configuration.'
-
  name: Github Copilot
  ring: trial
  quadrant: tools
  isNew: TRUE
  description: 'GitHub Copilot is an AI pair programmer, it will give you autocomplete suggestions while writing new code. GitHub Copilot can give suggestions based on natural language comments or based on the code you have written. GitHub Copilot analyzes the context in the files you are working with and based on that it will offer suggestions. GitHub Copilot supports multiple languages; Python, JavaScript, TypeScript, Ruby, Go, C#, or C++. GitHub Copilot is available as an extension in Visual Studio Code, Visual Studio, Neovim and the JetBrains suite of IDEs. Some final notes; we are interested in the possibilities of GitHub CoPilot but we have also read about some events where GitHub CoPilot is infringing copyright.'
-
  name: DevToys
  ring: adopt
  quadrant: tools
  isNew: TRUE
  description: 'A Swiss Army knife for developers, including converters, encoders, generators; on top of that it''s open source so feel free to add your own additional tools. It can automatically apply the desired action based on the latest clipboard content. So, if you open the tool after copying a JWT token onto the clipboard, it will show the decoded token in the JWT decoder tool. An additional benefit over various online tools is the offline availability and security by removing the need to send private / confidential data to potential malicious websites.'